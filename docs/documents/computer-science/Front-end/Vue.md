Vue

# Vue2

# Vue3

## 源码分析

### 整体模块划分

整体模块划分为三大块，**compiler-module，renderer-module，reactivity-module**

- 编译器模块 compiler 将视图模板编译成一个**渲染函数**
- 数据响应式模块 reactivity 将模板中使用到的数据对象变为为响应式对象
- 渲染模块开始进入渲染阶段(render phase)，调用刚刚生成的**渲染函数**，观察响应式数据对象的变化，并返回一个**虚拟的 DOM 节点**
- 然后在挂载阶段(mount phase)，调用`mount`函数，使用**虚拟 DOM 节点**来创建 web 页面
- 当观察的响应式对象发生变化时，渲染模块会再次调用**渲染函数**创建一个新的虚拟 DOM 节点，然后发送到`patch`函数中，进行 DOM diff，然后更新视图

####响应式原理分析

**个人简单理解一下整理的流程**

**详细内容**

1. reactive

   > http://www.zhufengpeixun.com/advance/guide/04.reactivity-2.html#reactivity%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8
   >
   > 密码：2558@手机号后四位

2. effect

3. watch
4. computed
5. ref

### 虚拟 DOM

## Diff 算法

### vue3 diff 算法

vue3 中比较子元素数组，使用到了 diff 算法，具体的流程如下：

统一使用案例

```javascript
c1: [a, b, c, d, e, f, g]; // 之前的子元素
c2: [a, b, e, c, d, h, f, g]; // 新的子元素
```

1. **先从头开始比**

   按上面的例子，那么可以排除掉 ab 不需要重新渲染

   ```javascript
   // 第一轮筛选过后
   [a, b, c, d, e, f, g][(a, b, e, c, d, h, f, g)][ // 之前的子元素 // 新的子元素
     // 筛选结果，可以不需要重新渲染ab
     (a, b)
   ][(c, d, e, f, g)][(a, b)][(e, c, d, h, f, g)]; // 之前的子元素 // 新的子元素
   ```

2. **再从尾部开始比**

   继续筛选，可以筛掉 fg，根据下标，进行 unmount

   ```javascript
   // 第二轮筛选过后
   [c, d, e, f, g][(e, c, d, h, f, g)][ // 之前的子元素 // 新的子元素
     // 筛选结果，可以不需要重新渲染fg
     (c, d, e)
   ][(f, g)][(e, c, d, h)][(f, g)]; // 之前的子元素 // 新的子元素
   ```

3. **然后判断是否为最简单的插入和删除操作**

   本情况，另起一个新例子，不看上面的，如下

   ```javascript
   // 案例1 --------------------------
   [a, b, c][(a, b, c, d)][
     // 第一二轮筛选完成后，发现老节点已经没了，剩下一个新节点d，直接进行插入d的操作即可

     // 案例2 --------------------------
     (a, b, c, d)
   ][(a, b, c)];
   // 第一二轮筛选完成后，发现新节点已经没了，剩下一个老节点d，直接进行删除d的操作即可
   ```

   上面两案例中，经过第一轮，第二轮的筛选过后，会存在一个情况，那就是新或老元素节点其中一方已经空了，没了，那就不需要进行下面第四步的乱序比较了，直接进行插入和删除即可

4. **如果不是上述的简单情况，那么就需要进行复杂比对了**

   继续回到统一案例中，当经过一二轮筛选后，而且发现新老节点都还有剩下，那么就不会走第三步。接下来，就需要进行复杂的乱序比较了

   ```javascript
   // 经过第一二轮的筛选，剩下的为
   c1: [a, b][(c, d, e)][(f, g)]; // 老节点
   c2: [a, b][(e, c, d, h)][(f, g)](
     // 新节点
     // 其中，c1代表老节点List, c2代表新节点list

     // 还有几个变量要注意，s1, e1, s2, e2，分别对应老节点的开始，老节点的结束，新节点的开始，新节点的结束对应的数组下标index
     s1
   )(e1);
   c1: [a, b][(c, d, e)][(f, g)]; // 老节点
   c2: [a, b][(e, c, d, h)][(f, g)](
     // 新节点
     s2
   )(e2);
   // s1 = 2, e1 = 4
   // s2 = 2, e2 = 5
   ```

   - 4.1 第一步，先创建一个 c2 中新节点的 map 映射表

     ```javascript
     let keyToNewIndexMap = new Map();
     // 从s2到e2，创建映射表
     for (let i = s2; i <= e2; i++) {
       // 键为子元素的key，值为子元素的c2数组下标
       keyToNewIndexMap.set(c2[i].key, i);
     }
     // keyToNewIndexMap
     // [e:2, c:3, d:4, h:5]
     ```

   - 4.2 第二步，循环老元素 c1，看新的里面有没有，如果有，比较差异并添加，如果没有，就删掉老元素

     ```javascript

     ```

### 最长递增子序列
