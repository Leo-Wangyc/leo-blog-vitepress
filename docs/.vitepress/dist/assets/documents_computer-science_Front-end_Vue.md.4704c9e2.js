import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.4719a631.js";const g=JSON.parse('{"title":"Vue2","description":"","frontmatter":{},"headers":[],"relativePath":"documents/computer-science/Front-end/Vue.md","filePath":"documents/computer-science/Front-end/Vue.md"}'),l={name:"documents/computer-science/Front-end/Vue.md"},e=p(`<p>Vue</p><h1 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h1><h1 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h1><h2 id="源码分析" tabindex="-1">源码分析 <a class="header-anchor" href="#源码分析" aria-label="Permalink to &quot;源码分析&quot;">​</a></h2><h3 id="整体模块划分" tabindex="-1">整体模块划分 <a class="header-anchor" href="#整体模块划分" aria-label="Permalink to &quot;整体模块划分&quot;">​</a></h3><p>整体模块划分为三大块，<strong>compiler-module，renderer-module，reactivity-module</strong></p><ul><li>编译器模块 compiler 将视图模板编译成一个<strong>渲染函数</strong></li><li>数据响应式模块 reactivity 将模板中使用到的数据对象变为为响应式对象</li><li>渲染模块开始进入渲染阶段(render phase)，调用刚刚生成的<strong>渲染函数</strong>，观察响应式数据对象的变化，并返回一个<strong>虚拟的 DOM 节点</strong></li><li>然后在挂载阶段(mount phase)，调用<code>mount</code>函数，使用<strong>虚拟 DOM 节点</strong>来创建 web 页面</li><li>当观察的响应式对象发生变化时，渲染模块会再次调用<strong>渲染函数</strong>创建一个新的虚拟 DOM 节点，然后发送到<code>patch</code>函数中，进行 DOM diff，然后更新视图</li></ul><p>####响应式原理分析</p><p><strong>个人简单理解一下整理的流程</strong></p><p><strong>详细内容</strong></p><ol><li><p>reactive</p><blockquote><p><a href="http://www.zhufengpeixun.com/advance/guide/04.reactivity-2.html#reactivity%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" target="_blank" rel="noreferrer">http://www.zhufengpeixun.com/advance/guide/04.reactivity-2.html#reactivity模块基本使用</a></p><p>密码：2558@手机号后四位</p></blockquote></li><li><p>effect</p></li><li><p>watch</p></li><li><p>computed</p></li><li><p>ref</p></li></ol><h3 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h3><h2 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h2><h3 id="vue3-diff-算法" tabindex="-1">vue3 diff 算法 <a class="header-anchor" href="#vue3-diff-算法" aria-label="Permalink to &quot;vue3 diff 算法&quot;">​</a></h3><p>vue3 中比较子元素数组，使用到了 diff 算法，具体的流程如下：</p><p>统一使用案例</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">c1</span><span style="color:#E1E4E8;">: [a, b, c, d, e, f, g]; </span><span style="color:#6A737D;">// 之前的子元素</span></span>
<span class="line"><span style="color:#B392F0;">c2</span><span style="color:#E1E4E8;">: [a, b, e, c, d, h, f, g]; </span><span style="color:#6A737D;">// 新的子元素</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">c1</span><span style="color:#24292E;">: [a, b, c, d, e, f, g]; </span><span style="color:#6A737D;">// 之前的子元素</span></span>
<span class="line"><span style="color:#6F42C1;">c2</span><span style="color:#24292E;">: [a, b, e, c, d, h, f, g]; </span><span style="color:#6A737D;">// 新的子元素</span></span></code></pre></div><ol><li><p><strong>先从头开始比</strong></p><p>按上面的例子，那么可以排除掉 ab 不需要重新渲染</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 第一轮筛选过后</span></span>
<span class="line"><span style="color:#E1E4E8;">[a, b, c, d, e, f, g][(a, b, e, c, d, h, f, g)][ </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 筛选结果，可以不需要重新渲染ab</span></span>
<span class="line"><span style="color:#E1E4E8;">  (a, b)</span></span>
<span class="line"><span style="color:#E1E4E8;">][(c, d, e, f, g)][(a, b)][(e, c, d, h, f, g)]; </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 第一轮筛选过后</span></span>
<span class="line"><span style="color:#24292E;">[a, b, c, d, e, f, g][(a, b, e, c, d, h, f, g)][ </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 筛选结果，可以不需要重新渲染ab</span></span>
<span class="line"><span style="color:#24292E;">  (a, b)</span></span>
<span class="line"><span style="color:#24292E;">][(c, d, e, f, g)][(a, b)][(e, c, d, h, f, g)]; </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span></code></pre></div></li><li><p><strong>再从尾部开始比</strong></p><p>继续筛选，可以筛掉 fg，根据下标，进行 unmount</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 第二轮筛选过后</span></span>
<span class="line"><span style="color:#E1E4E8;">[c, d, e, f, g][(e, c, d, h, f, g)][ </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 筛选结果，可以不需要重新渲染fg</span></span>
<span class="line"><span style="color:#E1E4E8;">  (c, d, e)</span></span>
<span class="line"><span style="color:#E1E4E8;">][(f, g)][(e, c, d, h)][(f, g)]; </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 第二轮筛选过后</span></span>
<span class="line"><span style="color:#24292E;">[c, d, e, f, g][(e, c, d, h, f, g)][ </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 筛选结果，可以不需要重新渲染fg</span></span>
<span class="line"><span style="color:#24292E;">  (c, d, e)</span></span>
<span class="line"><span style="color:#24292E;">][(f, g)][(e, c, d, h)][(f, g)]; </span><span style="color:#6A737D;">// 之前的子元素 // 新的子元素</span></span></code></pre></div></li><li><p><strong>然后判断是否为最简单的插入和删除操作</strong></p><p>本情况，另起一个新例子，不看上面的，如下</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 案例1 --------------------------</span></span>
<span class="line"><span style="color:#E1E4E8;">[a, b, c][(a, b, c, d)][</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 第一二轮筛选完成后，发现老节点已经没了，剩下一个新节点d，直接进行插入d的操作即可</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 案例2 --------------------------</span></span>
<span class="line"><span style="color:#E1E4E8;">  (a, b, c, d)</span></span>
<span class="line"><span style="color:#E1E4E8;">][(a, b, c)];</span></span>
<span class="line"><span style="color:#6A737D;">// 第一二轮筛选完成后，发现新节点已经没了，剩下一个老节点d，直接进行删除d的操作即可</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 案例1 --------------------------</span></span>
<span class="line"><span style="color:#24292E;">[a, b, c][(a, b, c, d)][</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 第一二轮筛选完成后，发现老节点已经没了，剩下一个新节点d，直接进行插入d的操作即可</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 案例2 --------------------------</span></span>
<span class="line"><span style="color:#24292E;">  (a, b, c, d)</span></span>
<span class="line"><span style="color:#24292E;">][(a, b, c)];</span></span>
<span class="line"><span style="color:#6A737D;">// 第一二轮筛选完成后，发现新节点已经没了，剩下一个老节点d，直接进行删除d的操作即可</span></span></code></pre></div><p>上面两案例中，经过第一轮，第二轮的筛选过后，会存在一个情况，那就是新或老元素节点其中一方已经空了，没了，那就不需要进行下面第四步的乱序比较了，直接进行插入和删除即可</p></li><li><p><strong>如果不是上述的简单情况，那么就需要进行复杂比对了</strong></p><p>继续回到统一案例中，当经过一二轮筛选后，而且发现新老节点都还有剩下，那么就不会走第三步。接下来，就需要进行复杂的乱序比较了</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 经过第一二轮的筛选，剩下的为</span></span>
<span class="line"><span style="color:#B392F0;">c1</span><span style="color:#E1E4E8;">: [a, b][(c, d, e)][(f, g)]; </span><span style="color:#6A737D;">// 老节点</span></span>
<span class="line"><span style="color:#B392F0;">c2</span><span style="color:#E1E4E8;">: [a, b][(e, c, d, h)][(f, g)](</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 新节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 其中，c1代表老节点List, c2代表新节点list</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 还有几个变量要注意，s1, e1, s2, e2，分别对应老节点的开始，老节点的结束，新节点的开始，新节点的结束对应的数组下标index</span></span>
<span class="line"><span style="color:#E1E4E8;">  s1</span></span>
<span class="line"><span style="color:#E1E4E8;">)(e1);</span></span>
<span class="line"><span style="color:#B392F0;">c1</span><span style="color:#E1E4E8;">: [a, b][(c, d, e)][(f, g)]; </span><span style="color:#6A737D;">// 老节点</span></span>
<span class="line"><span style="color:#B392F0;">c2</span><span style="color:#E1E4E8;">: [a, b][(e, c, d, h)][(f, g)](</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 新节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  s2</span></span>
<span class="line"><span style="color:#E1E4E8;">)(e2);</span></span>
<span class="line"><span style="color:#6A737D;">// s1 = 2, e1 = 4</span></span>
<span class="line"><span style="color:#6A737D;">// s2 = 2, e2 = 5</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 经过第一二轮的筛选，剩下的为</span></span>
<span class="line"><span style="color:#6F42C1;">c1</span><span style="color:#24292E;">: [a, b][(c, d, e)][(f, g)]; </span><span style="color:#6A737D;">// 老节点</span></span>
<span class="line"><span style="color:#6F42C1;">c2</span><span style="color:#24292E;">: [a, b][(e, c, d, h)][(f, g)](</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 新节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 其中，c1代表老节点List, c2代表新节点list</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 还有几个变量要注意，s1, e1, s2, e2，分别对应老节点的开始，老节点的结束，新节点的开始，新节点的结束对应的数组下标index</span></span>
<span class="line"><span style="color:#24292E;">  s1</span></span>
<span class="line"><span style="color:#24292E;">)(e1);</span></span>
<span class="line"><span style="color:#6F42C1;">c1</span><span style="color:#24292E;">: [a, b][(c, d, e)][(f, g)]; </span><span style="color:#6A737D;">// 老节点</span></span>
<span class="line"><span style="color:#6F42C1;">c2</span><span style="color:#24292E;">: [a, b][(e, c, d, h)][(f, g)](</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 新节点</span></span>
<span class="line"><span style="color:#24292E;">  s2</span></span>
<span class="line"><span style="color:#24292E;">)(e2);</span></span>
<span class="line"><span style="color:#6A737D;">// s1 = 2, e1 = 4</span></span>
<span class="line"><span style="color:#6A737D;">// s2 = 2, e2 = 5</span></span></code></pre></div><ul><li><p>4.1 第一步，先创建一个 c2 中新节点的 map 映射表</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> keyToNewIndexMap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Map</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 从s2到e2，创建映射表</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s2; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> e2; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 键为子元素的key，值为子元素的c2数组下标</span></span>
<span class="line"><span style="color:#E1E4E8;">  keyToNewIndexMap.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(c2[i].key, i);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// keyToNewIndexMap</span></span>
<span class="line"><span style="color:#6A737D;">// [e:2, c:3, d:4, h:5]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> keyToNewIndexMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Map</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 从s2到e2，创建映射表</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s2; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> e2; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 键为子元素的key，值为子元素的c2数组下标</span></span>
<span class="line"><span style="color:#24292E;">  keyToNewIndexMap.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(c2[i].key, i);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// keyToNewIndexMap</span></span>
<span class="line"><span style="color:#6A737D;">// [e:2, c:3, d:4, h:5]</span></span></code></pre></div></li><li><p>4.2 第二步，循环老元素 c1，看新的里面有没有，如果有，比较差异并添加，如果没有，就删掉老元素</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span></code></pre></div></li></ul></li></ol><h3 id="最长递增子序列" tabindex="-1">最长递增子序列 <a class="header-anchor" href="#最长递增子序列" aria-label="Permalink to &quot;最长递增子序列&quot;">​</a></h3>`,19),o=[e];function c(t,r,i,d,y,E){return a(),n("div",null,o)}const u=s(l,[["render",c]]);export{g as __pageData,u as default};
